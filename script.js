// ゲームに関する設定を表す定数
const ゲーム盤の行の数 = 20;  // ゲーム盤の大きさ
const ゲーム盤の列の数 = 10;
const マスの大きさ = 20;      // ゲーム盤のマスの大きさ
const ゲーム盤の位置x = 10.5; // ゲーム盤の表示位置
const ゲーム盤の位置y = 10.5;
const キャンバスの幅 = 380;   // キャンバスの大きさ
const キャンバスの高さ = 420;
// 次のポリオミノの表示位置。座標はゲーム盤のマスの位置で表現する
const 次のポリオミノの表示位置x = ゲーム盤の列の数 + 1;
const 次のポリオミノの表示位置y = 1.5;
// NEXTの表示位置。座標はcanvasの座標で表現する
const NEXTの表示位置x = ゲーム盤の位置x + ゲーム盤の列の数 * マスの大きさ + 25;
const NEXTの表示位置y = 30;
// ゲームオーバーの表示位置。座標はcanvasの座標で表現する
const ゲームオーバーの表示位置x = ゲーム盤の位置x +
  ゲーム盤の列の数 * マスの大きさ + 25;
const ゲームオーバーの表示位置y = 200;
// ポリオミノの種類ごとに、ブロックの色と配置のデータを配列で表現する
const ポリオミノのデータ = [
  // 0 番のポリオミノのデータ
  {
    色: "skyblue",        // ブロックの色
    配置: [
      [                   // 回転番号が「0」のブロックの形
        { x: 0, y: 1 },   //  0123
        { x: 1, y: 1 },   // 0
        { x: 2, y: 1 },   // 1XXXX
        { x: 3, y: 1 },   // 2
      ],                  // 3
      [                   // 回転番号が「1」のブロックの形
        { x: 1, y: 0 },   //  0123
        { x: 1, y: 1 },   // 0 X
        { x: 1, y: 2 },   // 1 X
        { x: 1, y: 3 },   // 2 X
      ],                  // 3 X
    ],
  },
  // 1 番のポリオミノのブロックの配置データ
  {
    色: "purple",         // ブロックの色
    配置: [
      [                   // 回転番号が「0」のブロックの形
        { x: 1, y: 0 },   //  0123
        { x: 0, y: 1 },   // 0 X
        { x: 1, y: 1 },   // 1XXX
        { x: 2, y: 1 },   // 2
      ],                  // 3
      [                   // 回転番号が「1」のブロックの形
        { x: 1, y: 0 },   //  0123
        { x: 1, y: 1 },   // 0 X
        { x: 2, y: 1 },   // 1 XX
        { x: 1, y: 2 },   // 2 X
      ],                  // 3
      [                   // 回転番号が「2」のブロックの形
        { x: 0, y: 1 },   //  0123
        { x: 1, y: 1 },   // 0
        { x: 2, y: 1 },   // 1XXX
        { x: 1, y: 2 },   // 2 X
      ],                  // 3
      [                   // 回転番号が「3」のブロックの形
        { x: 1, y: 0 },   //  0123
        { x: 0, y: 1 },   // 0 X
        { x: 1, y: 1 },   // 1XX
        { x: 1, y: 2 },   // 2 X
      ],                  // 3
    ],
  },
  {
    色: "yellow",        // ブロックの色
    配置: [
      [                             // 回転番号が「0」のブロックの形
        { x: 0, y: 0 },   //  0123
        { x: 1, y: 0 },   // 0
        { x: 0, y: 1 },   // 1 XX
        { x: 1, y: 1 },   // 2 XX
      ],                            // 3
    ],
  },
  {
    色: "green",
    配置: [
      [
        { x: 1, y: 0 },
        { x: 2, y: 0 },
        { x: 0, y: 1 },
        { x: 1, y: 1 },
      ],
      [
        { x: 0, y: 0 },
        { x: 0, y: 1 },
        { x: 1, y: 1 },
        { x: 1, y: 2 },
      ],
    ],
  },
  {
    色: "red",
    配置: [
      [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 1, y: 1 },
        { x: 2, y: 1 },
      ],
      [
        { x: 1, y: 0 },
        { x: 0, y: 1 },
        { x: 1, y: 1 },
        { x: 0, y: 2 },
      ],
    ],
  },
  {
    色: "blue",
    配置: [
      [
        { x: 2, y: 0 },
        { x: 0, y: 1 },
        { x: 1, y: 1 },
        { x: 2, y: 1 },
      ],
      [
        { x: 0, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: 2 },
        { x: 1, y: 2 },
      ],
      [
        { x: 0, y: 1 },
        { x: 1, y: 1 },
        { x: 2, y: 1 },
        { x: 0, y: 2 },
      ],
      [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 1, y: 1 },
        { x: 1, y: 2 },
      ],
    ],
  },
  {
    色: "orange",
    配置: [
      [
        { x: 0, y: 0 },
        { x: 0, y: 1 },
        { x: 1, y: 1 },
        { x: 2, y: 1 },
      ],
      [
        { x: 0, y: 0 },
        { x: 1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: 2 },
      ],
      [
        { x: 0, y: 1 },
        { x: 1, y: 1 },
        { x: 2, y: 1 },
        { x: 2, y: 2 },
      ],
      [
        { x: 1, y: 0 },
        { x: 1, y: 1 },
        { x: 0, y: 2 },
        { x: 1, y: 2 },
      ],
    ],
  },
];

// ゲームで使用する様々な大域変数
let canvas; // キャンバスの要素オブジェクト
let ctx;    // キャンバスの描画コンテキスト
let ゲーム盤のブロック;  // ゲーム盤に配置されたブロックの番号を表す2次元配列
// 操作するポリオミノのデータを記憶するオブジェクト
// 以下のプロパティを持つ
//   x, y:        　　ポリオミノのゲーム盤上の座標
//   種類:        　　ポリオミノの種類を表す表す番号
//   色:          　　ポリオミノのブロックの色
//   回転:        　　ポリオミノ回転番号
// 　ブロックの配置:　ポリオミノのブロックの配置を表す配列のデータ
let ポリオミノ = {};
// 次のポリオミノを記憶するオブジェクト。プロパティは「ポリオミノ」と同じ
let 次のポリオミノ = {};
// ゲームの状態を表す変数。"ゲーム中"と"ゲームオーバー"の2つの状態を持つ
let ゲームの状態;

window.onload = function () {
  // キャンバスの要素オブジェクトを取得する
  canvas = document.getElementById("キャンバス");
  // キャンバスの大きさを変更する
  canvas.width = キャンバスの幅;
  canvas.height = キャンバスの高さ;
  // 2次元の描画コンテキストを取得する
  ctx = canvas.getContext("2d");

  // ウェブページ上でキーを押したときのイベントハンドラを設定する
  document.onkeydown = キー入力処理;

  // ゲームを初期化する
  ゲーム初期化処理();
};

// ゲームを新しく開始する際の初期化処理を行う関数
function ゲーム初期化処理() {
  // ゲーム盤上のブロックをすべてクリアする
  // ゲーム盤のブロックを空の配列で初期化する
  ゲーム盤のブロック = [];
  // 各列に対する繰り返し処理を行う
  for (let x = 0; x < ゲーム盤の列の数; x++) {
    // x列の要素に空の配列を代入する
    ゲーム盤のブロック[x] = [];
    // x列の各行に対する繰り返し処理を行う
    for (let y = 0; y < ゲーム盤の行の数; y++) {
      // 全ての(x, y) の組み合わせで下記のプログラムが実行される
      // 結果として「ゲーム盤のブロック」の全てのマスが「-1」になる
      ゲーム盤のブロック[x][y] = -1;
    }
  }

  // ゲームの状態を"ゲーム中"にする
  ゲームの状態 = "ゲーム中";
  // 次のポリオミノをランダムに設定する関数を呼び出す
  次のポリオミノの設定();
  // 新しいポリオミノを設定する
  新しいポリオミノの設定();
  // 画面描画する関数を呼び出す
  画面描画();
}

// －－－「画面の描画」に関する関数－－－－－－
// 画面全般を描画する関数
function 画面描画() {
  // キャンバスの描画をすべてクリアする
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 最初に全てのマスに、薄い灰色の枠を描画しておく
  for (let x = 0; x < ゲーム盤の列の数; x++) {
    for (let y = 0; y < ゲーム盤の行の数; y++) {
      ブロックの描画(x, y, "transparent", "lightgray");
    }
  }
  // ゲーム盤の枠を表示する
  ctx.beginPath();
  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;
  ctx.rect(ゲーム盤の位置x, ゲーム盤の位置y,
    ゲーム盤の列の数 * マスの大きさ,
    ゲーム盤の行の数 * マスの大きさ);
  ctx.stroke();

  // ゲーム盤のブロックを表示する
  // 繰り返しを入れ子にすることで、全てのマスに対して処理を行う
  for (let x = 0; x < ゲーム盤の列の数; x++) {
    for (let y = 0; y < ゲーム盤の行の数; y++) {
      // (x, y) のマスのブロックの番号を取得する
      const ブロックの番号 = ゲーム盤のブロック[x][y];
      // ブロックが配置されているかどうかをチェックする
      if (ブロックの番号 >= 0) {
        // ブロックの番号に対応する色を取得し、ブロックを描画する関数を呼ぶ
        const 色 = ポリオミノのデータ[ブロックの番号].色;
        ブロックの描画(x, y, 色, "black");
      }
    }
  }

  // ポリオミノの描画を行う関数を呼びだして、「ポリオミノ」を描画する
  ポリオミノの描画(ポリオミノ);
  // ポリオミノの描画を行う関数を呼びだして、「次のポリオミノ」を描画する
  ポリオミノの描画(次のポリオミノ);
  // 次のポリオミノの上に、"NEXT"を表示する
  ctx.fillStyle = "black";
  ctx.font = "20px Century";
  ctx.fillText("NEXT", NEXTの表示位置x, NEXTの表示位置y);

  // ゲームオーバー時の表示
  if (ゲームの状態 === "ゲームオーバー") {
    ctx.fillStyle = "black";
    ctx.font = "20px Century";
    ctx.fillText("Game Over", ゲームオーバーの表示位置x, ゲームオーバーの表示位置y);
    ctx.fillText("Sキーで開始", ゲームオーバーの表示位置x,
      ゲームオーバーの表示位置y + 24);
  }
}

// ゲーム盤にブロックを描画する
// 引数一覧：
//  x, y：            ブロックを描画するゲーム盤上のマスの座標
//  塗りつぶしの色：　ブロックの塗りつぶしの色
//  枠の色：　　　　　ブロックの枠の色
function ブロックの描画(x, y, 塗りつぶしの色, 枠の色) {
  ctx.beginPath();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 枠の色;
  ctx.fillStyle = 塗りつぶしの色;
  // ブロック表す長方形の左上の点の座標は、ゲーム盤の左上の座標である
  //（ゲーム盤の位置x, ゲーム盤の位置y）を基準とし、そこから
  // (x * マスの大きさ, y * マスの大きさ）だけずらした位置
  // ブロックの幅と高さは、「マスの大きさ」とおなじ
  ctx.rect(ゲーム盤の位置x + x * マスの大きさ,
    ゲーム盤の位置y + y * マスの大きさ,
    マスの大きさ, マスの大きさ);
  ctx.fill();
  ctx.stroke();
}

// 引数に渡されたポリオミノを画面に描画する
function ポリオミノの描画(描画するポリオミノ) {
  // 「ブロックの描画」を使ってポリオミノのブロックを描画する
  // 各ブロックの相対座標は「ブロックの配置」プロパティに配列で
  // 記憶されているので、繰り返しを使って各要素の描画を行う
  for (let i = 0; i < 描画するポリオミノ.ブロックの配置.length; i++) {
    // 各ブロックの、ゲーム盤上の座標を計算する
    const x = 描画するポリオミノ.x + 描画するポリオミノ.ブロックの配置[i].x;
    const y = 描画するポリオミノ.y + 描画するポリオミノ.ブロックの配置[i].y;
    ブロックの描画(x, y, 描画するポリオミノ.色, "black");
  }
}

// －－－－－－－－－－－－－－－－－－－－－－

// －－－「ポリオミノの処理」に関する関数－－－
// 新しいポリオミノを設定する関数
function 新しいポリオミノの設定() {
  // 「ポリオミノ」に、「次のポリオミノ」の中身（プロパティ）を全てコピーする
  ポリオミノ.x = 次のポリオミノ.x;
  ポリオミノ.y = 次のポリオミノ.y;
  ポリオミノ.種類 = 次のポリオミノ.種類;
  ポリオミノ.色 = 次のポリオミノ.色;
  ポリオミノ.回転 = 次のポリオミノ.回転;
  ポリオミノ.ブロックの配置 = 次のポリオミノ.ブロックの配置;
  // 次のポリオミノの座標はゲーム盤の外にあるので、座標だけは設定しなおす
  ポリオミノ.x = 0;
  ポリオミノ.y = 0;
  // 次のポリオミノをランダムに設定する関数を呼び出す
  次のポリオミノの設定();
  // ゲームオーバーの判定処理
  if (!ポリオミノを移動しても良いかどうか()) {
    ゲームの状態 = "ゲームオーバー";
  }
}

// 次のポリオミノをランダムに設定する
function 次のポリオミノの設定() {
  // 次のポリオミノの最初の位置を設定する
  次のポリオミノ.x = 次のポリオミノの表示位置x;
  次のポリオミノ.y = 次のポリオミノの表示位置y;
  // 次のポリオミノの種類の数は、ブロックの色の配列の要素数と同じ
  const ポリオミノの種類の数 = ポリオミノのデータ.length;
  // サイコロを振って、次のポリオミノの種類をランダムに決める
  次のポリオミノ.種類 = サイコロを振る(ポリオミノの種類の数) - 1;
  // ポリオミノの種類に応じたブロックの色を設定する
  次のポリオミノ.色 = ポリオミノのデータ[次のポリオミノ.種類].色;
  // 次のポリオミノの回転番号を「0」で初期化する。
  次のポリオミノ.回転 = 0;
  // 次のポリオミノを構成するブロックの配置データを「ポリオミノのデータ」から選択する
  次のポリオミノ.ブロックの配置 =
    ポリオミノのデータ[次のポリオミノ.種類].配置[次のポリオミノ.回転];
}

// ゲーム盤のポリオミノがあるマスに、ポリオミノのブロックを配置する
// その後、新しいポリオミノを設定する
function ポリオミノを配置する() {
  // 各ブロックの相対座標は「ブロックの配置」プロパティに配列で記憶
  // されている。繰り返しで、各配列の要素を使ってブロックの座標を計算する
  for (let i = 0; i < ポリオミノ.ブロックの配置.length; i++) {
    // 各ブロックの、ゲーム盤上の座標を計算する
    const x = ポリオミノ.x + ポリオミノ.ブロックの配置[i].x;
    const y = ポリオミノ.y + ポリオミノ.ブロックの配置[i].y;
    ゲーム盤のブロック[x][y] = ポリオミノ.種類;
  }
  新しいポリオミノの設定();
}

// ポリオミノを移動しても良いかどうかをチェックし、
// 移動しても良い場合は「true」、そうでなければ「false」を返す
function ポリオミノを移動しても良いかどうか() {
  // ゲーム盤内で、ブロックが配置されていなければ移動しても良い
  // 各ブロックの相対座標は「ブロックの配置」プロパティに配列で記憶
  // されている。繰り返しで、各配列の要素を使ってブロックの座標を計算する
  // 判定結果を表す変数。「true」で初期化しておく
  let 判定結果 = true;
  for (let i = 0; i < ポリオミノ.ブロックの配置.length; i++) {
    // 各ブロックの、ゲーム盤上の座標を計算する
    const x = ポリオミノ.x + ポリオミノ.ブロックの配置[i].x;
    const y = ポリオミノ.y + ポリオミノ.ブロックの配置[i].y;
    // 条件式が「false」の場合を「!」のNOT演算子を使ってチェックする
    if (!(ゲーム盤内のマスかどうか(x, y) && ゲーム盤のブロック[x][y] === -1)) {
      // 条件式が「false」の場合は判定結果を「false」にする
      判定結果 = false;
      // それ以上チェックするはないので、break文で繰り返しを中断する
      break;
    }
  }
  // return 文で、判定結果を返り値として返す
  return 判定結果;
}

// (x, y)のマスが、ゲーム盤内の場合は「true」、盤外の場合は「false」を返す関数
function ゲーム盤内のマスかどうか(x, y) {
  return 0 <= x && x < ゲーム盤の列の数 && 0 <= y && y < ゲーム盤の行の数;
}

// －－－－－－－－－－－－－－－－－－－－－－

// －－－「イベントハンドラ」に関する関数－－－
// キー入力処理を行う関数
function キー入力処理() {
  // ゲームオーバーの場合はキーをを効かなくする
  if (ゲームの状態 === "ゲームオーバー") {
    // Sキー（83）が押された時の処理
    if (event.keyCode === 83) {
      // ゲーム初期化処理を呼び出して新しいゲームを始める
      ゲーム初期化処理();
    }
    return;
  }
  // ポリオミノの移動前の位置を覚えておく
  const 元の位置x = ポリオミノ.x;
  const 元の位置y = ポリオミノ.y;
  const 元の回転 = ポリオミノ.回転;
  const 元の配置 = ポリオミノ.ブロックの配置;
  // 押されたキーに対応する処理を記述する
  switch (event.keyCode) {
    // 左のカーソルキー（37）が押された時の処理
    case 37:
      // ポリオミノを左に1マス移動する
      ポリオミノ.x--;
      break;
    // 右のカーソルキー（39）が押された時の処理
    case 39:
      // ポリオミノを右に1マス移動する
      ポリオミノ.x++;
      break;
    // 下のカーソルキー（40）が押された時の処理
    case 40:
      // ポリオミノを下に1マス移動する
      ポリオミノ.y++;
      break;
    case 32:
      // ポリオミノを1つ回転する
      ポリオミノ.回転++;
      // 回転番号が、回転のブロックの種類の数と同じ場合は回転番号を「0」に戻す
      if (ポリオミノ.回転 === ポリオミノのデータ[ポリオミノ.種類].配置.length) {
        ポリオミノ.回転 = 0;
      }
      // ブロックの配置データ更新する
      ポリオミノ.ブロックの配置 =
        ポリオミノのデータ[ポリオミノ.種類].配置[ポリオミノ.回転];
  }

  // 移動後の場所にポリオミノを移動して良いかどうかをチェックする
  if (!ポリオミノを移動しても良いかどうか()) {
    // 移動してはいけない場合は、ポリオミノの位置を元に戻す
    ポリオミノ.x = 元の位置x;
    ポリオミノ.y = 元の位置y;
    ポリオミノ.回転 = 元の回転;
    ポリオミノ.ブロックの配置 = 元の配置;
    // 「下」のキーが押されていた場合は、ポリオミノをゲーム盤に配置する
    if (event.keyCode === 40) {
      ポリオミノを配置する();
    }
  }
  // 画面の描画を更新する
  画面描画();
}

// －－－－－－－－－－－－－－－－－－－－－－

// －－－「その他」の関数－－－－－－－－－－－
// １～出目の最大値までのランダムな数を返す関数
function サイコロを振る(出目の最大値) {
  return Math.floor(Math.random() * 出目の最大値) + 1;
}

// －－－－－－－－－－－－－－－－－－－－－－

